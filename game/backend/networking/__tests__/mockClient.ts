import Connection from "../types";

class MockWebRTCConnection implements Connection {
  _client: TestClient | undefined;
  eventHandlers: Record<string, (data: string) => void> = {}
  constructor() {}
  send(data: string): void {
    if (!this._client) {
      throw new Error(
        "MockWebRTCConnection needs a ref to TestClient before it can send or receive data"
      );
    }
    this._client.onmessage(data);
  }

  on(event: string, cb: (data: string) => void) {
    this.eventHandlers[event] = jest.fn(cb)
  }

  dispatchEvent(eventName: string, data: string) {
    const cb = this.eventHandlers[eventName]
    if (!cb) {
      console.error('No callback registered for ', eventName)
      return
    }
    cb(data)
  }

  onmessage(data: string): void {}

  addTestClient(client: TestClient) {
    this._client = client;
  }
}

export const BATCH_INTERVAL = 100;
export const DEFAULT_WAIT_TIMEOUT = 2000;

export class TestClient {
  _connection: MockWebRTCConnection;
  _messageInbox: string[] = [];
  metadata: string;
  id: string;
  eventHandlers: Record<string, (data: string) => void> = {}
  // TODO: make the name be autogenerated, as well
  constructor(connection: MockWebRTCConnection, metadata: string) {
    this.id = window.btoa(metadata);
    this._connection = connection;
    this.metadata = metadata;
    this.onmessage = jest.fn(this.onmessage);

    this._connection.addTestClient(this);
  }

  send(data: string) {
    this._connection.dispatchEvent('data', data)
  }

  onmessage(data: string) {
    // console.log({ data });
    this._messageInbox.push(data);
  }

  async waitForMessage(
    messageId: string,
    data: Record<string, any> = {},
    timeout: number = DEFAULT_WAIT_TIMEOUT
  ) {
    const strData = JSON.stringify(data);
    const wrongMessagesData: string[] = [];
    let timeRemaining = timeout;

    const _checkNextBatch = () =>
      new Promise<void>((res, rej) => {
        setTimeout(() => {
          while (this._messageInbox.length) {
            const msg = JSON.parse(this._messageInbox.shift()!);

            if (!msg.type) {
              console.error(
                `[testClient] Received message without a 'type' property. Message: ${msg}`
              );
              continue;
            }

            if (!msg.data) {
              console.warn(
                `[testClient] Received message without a 'data' property. This could cause issues. Message: ${msg}`
              );
            }

            const recvStrData = JSON.stringify(msg.data);
            if (msg.type === messageId && strData === recvStrData) {
              return res();
            }

            if (msg.type === messageId) {
              wrongMessagesData.push(recvStrData);
            }
          }
          rej();
        }, BATCH_INTERVAL);
      });

    while (true) {
      try {
        await _checkNextBatch();
      } catch {
        if (timeRemaining < 0) {
          break;
        }
        timeRemaining -= BATCH_INTERVAL;
        continue;
      }
      return;
    }

    if (wrongMessagesData.length) {
      throw new Error(
        `${
          this.metadata
        } Received ${messageId} message, but with wrong data. Expected: ${strData} Received: ${wrongMessagesData.join(
          "\n"
        )}`
      );
    }

    throw new Error(
      `${this.metadata} Did not receive ${messageId} message with data ${strData}`
    );
  }
}

let idCount = 0;

const _getTestClientId = (count: number) => `test_client_${idCount}`;

export function getTestClient() {
  const clientId = _getTestClientId(idCount);
  idCount++;
  const connection = new MockWebRTCConnection();
  clientIdByConnection[clientId] = connection;
  return [new TestClient(connection, clientId), connection] as const;
}

const clientIdByConnection: Record<string, MockWebRTCConnection> = {};

export function getMockConnection(metadata: string) {
  return clientIdByConnection[metadata];
}
